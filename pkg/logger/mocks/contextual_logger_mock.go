// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"sync"
)

// ContextualLoggerMock is a mock implementation of logger.ContextualLogger.
//
//	func TestSomethingThatUsesContextualLogger(t *testing.T) {
//
//		// make and configure a mocked logger.ContextualLogger
//		mockedContextualLogger := &ContextualLoggerMock{
//			DebugFunc: func(ctx context.Context, args ...interface{})  {
//				panic("mock out the Debug method")
//			},
//			ErrorFunc: func(ctx context.Context, args ...interface{})  {
//				panic("mock out the Error method")
//			},
//			InfoFunc: func(ctx context.Context, args ...interface{})  {
//				panic("mock out the Info method")
//			},
//			WarningFunc: func(ctx context.Context, args ...interface{})  {
//				panic("mock out the Warning method")
//			},
//			WithErrorFunc: func(ctx context.Context, err error) context.Context {
//				panic("mock out the WithError method")
//			},
//			WithFieldFunc: func(ctx context.Context, k string, v interface{}) context.Context {
//				panic("mock out the WithField method")
//			},
//			WithFieldsFunc: func(ctx context.Context, fields map[string]interface{}) context.Context {
//				panic("mock out the WithFields method")
//			},
//		}
//
//		// use mockedContextualLogger in code that requires logger.ContextualLogger
//		// and then make assertions.
//
//	}
type ContextualLoggerMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(ctx context.Context, args ...interface{})

	// ErrorFunc mocks the Error method.
	ErrorFunc func(ctx context.Context, args ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(ctx context.Context, args ...interface{})

	// WarningFunc mocks the Warning method.
	WarningFunc func(ctx context.Context, args ...interface{})

	// WithErrorFunc mocks the WithError method.
	WithErrorFunc func(ctx context.Context, err error) context.Context

	// WithFieldFunc mocks the WithField method.
	WithFieldFunc func(ctx context.Context, k string, v interface{}) context.Context

	// WithFieldsFunc mocks the WithFields method.
	WithFieldsFunc func(ctx context.Context, fields map[string]interface{}) context.Context

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []interface{}
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []interface{}
		}
		// Warning holds details about calls to the Warning method.
		Warning []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []interface{}
		}
		// WithError holds details about calls to the WithError method.
		WithError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Err is the err argument value.
			Err error
		}
		// WithField holds details about calls to the WithField method.
		WithField []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// K is the k argument value.
			K string
			// V is the v argument value.
			V interface{}
		}
		// WithFields holds details about calls to the WithFields method.
		WithFields []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fields is the fields argument value.
			Fields map[string]interface{}
		}
	}
	lockDebug      sync.RWMutex
	lockError      sync.RWMutex
	lockInfo       sync.RWMutex
	lockWarning    sync.RWMutex
	lockWithError  sync.RWMutex
	lockWithField  sync.RWMutex
	lockWithFields sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *ContextualLoggerMock) Debug(ctx context.Context, args ...interface{}) {
	callInfo := struct {
		Ctx  context.Context
		Args []interface{}
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	if mock.DebugFunc == nil {
		return
	}
	mock.DebugFunc(ctx, args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedContextualLogger.DebugCalls())
func (mock *ContextualLoggerMock) DebugCalls() []struct {
	Ctx  context.Context
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Args []interface{}
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *ContextualLoggerMock) Error(ctx context.Context, args ...interface{}) {
	callInfo := struct {
		Ctx  context.Context
		Args []interface{}
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	if mock.ErrorFunc == nil {
		return
	}
	mock.ErrorFunc(ctx, args...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedContextualLogger.ErrorCalls())
func (mock *ContextualLoggerMock) ErrorCalls() []struct {
	Ctx  context.Context
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Args []interface{}
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *ContextualLoggerMock) Info(ctx context.Context, args ...interface{}) {
	callInfo := struct {
		Ctx  context.Context
		Args []interface{}
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	if mock.InfoFunc == nil {
		return
	}
	mock.InfoFunc(ctx, args...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedContextualLogger.InfoCalls())
func (mock *ContextualLoggerMock) InfoCalls() []struct {
	Ctx  context.Context
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Args []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Warning calls WarningFunc.
func (mock *ContextualLoggerMock) Warning(ctx context.Context, args ...interface{}) {
	callInfo := struct {
		Ctx  context.Context
		Args []interface{}
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockWarning.Lock()
	mock.calls.Warning = append(mock.calls.Warning, callInfo)
	mock.lockWarning.Unlock()
	if mock.WarningFunc == nil {
		return
	}
	mock.WarningFunc(ctx, args...)
}

// WarningCalls gets all the calls that were made to Warning.
// Check the length with:
//
//	len(mockedContextualLogger.WarningCalls())
func (mock *ContextualLoggerMock) WarningCalls() []struct {
	Ctx  context.Context
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Args []interface{}
	}
	mock.lockWarning.RLock()
	calls = mock.calls.Warning
	mock.lockWarning.RUnlock()
	return calls
}

// WithError calls WithErrorFunc.
func (mock *ContextualLoggerMock) WithError(ctx context.Context, err error) context.Context {
	callInfo := struct {
		Ctx context.Context
		Err error
	}{
		Ctx: ctx,
		Err: err,
	}
	mock.lockWithError.Lock()
	mock.calls.WithError = append(mock.calls.WithError, callInfo)
	mock.lockWithError.Unlock()
	if mock.WithErrorFunc == nil {
		var (
			contextOut context.Context
		)
		return contextOut
	}
	return mock.WithErrorFunc(ctx, err)
}

// WithErrorCalls gets all the calls that were made to WithError.
// Check the length with:
//
//	len(mockedContextualLogger.WithErrorCalls())
func (mock *ContextualLoggerMock) WithErrorCalls() []struct {
	Ctx context.Context
	Err error
} {
	var calls []struct {
		Ctx context.Context
		Err error
	}
	mock.lockWithError.RLock()
	calls = mock.calls.WithError
	mock.lockWithError.RUnlock()
	return calls
}

// WithField calls WithFieldFunc.
func (mock *ContextualLoggerMock) WithField(ctx context.Context, k string, v interface{}) context.Context {
	callInfo := struct {
		Ctx context.Context
		K   string
		V   interface{}
	}{
		Ctx: ctx,
		K:   k,
		V:   v,
	}
	mock.lockWithField.Lock()
	mock.calls.WithField = append(mock.calls.WithField, callInfo)
	mock.lockWithField.Unlock()
	if mock.WithFieldFunc == nil {
		var (
			contextOut context.Context
		)
		return contextOut
	}
	return mock.WithFieldFunc(ctx, k, v)
}

// WithFieldCalls gets all the calls that were made to WithField.
// Check the length with:
//
//	len(mockedContextualLogger.WithFieldCalls())
func (mock *ContextualLoggerMock) WithFieldCalls() []struct {
	Ctx context.Context
	K   string
	V   interface{}
} {
	var calls []struct {
		Ctx context.Context
		K   string
		V   interface{}
	}
	mock.lockWithField.RLock()
	calls = mock.calls.WithField
	mock.lockWithField.RUnlock()
	return calls
}

// WithFields calls WithFieldsFunc.
func (mock *ContextualLoggerMock) WithFields(ctx context.Context, fields map[string]interface{}) context.Context {
	callInfo := struct {
		Ctx    context.Context
		Fields map[string]interface{}
	}{
		Ctx:    ctx,
		Fields: fields,
	}
	mock.lockWithFields.Lock()
	mock.calls.WithFields = append(mock.calls.WithFields, callInfo)
	mock.lockWithFields.Unlock()
	if mock.WithFieldsFunc == nil {
		var (
			contextOut context.Context
		)
		return contextOut
	}
	return mock.WithFieldsFunc(ctx, fields)
}

// WithFieldsCalls gets all the calls that were made to WithFields.
// Check the length with:
//
//	len(mockedContextualLogger.WithFieldsCalls())
func (mock *ContextualLoggerMock) WithFieldsCalls() []struct {
	Ctx    context.Context
	Fields map[string]interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Fields map[string]interface{}
	}
	mock.lockWithFields.RLock()
	calls = mock.calls.WithFields
	mock.lockWithFields.RUnlock()
	return calls
}
